{
    "componentChunkName": "component---src-templates-mdx-js",
    "path": "/uilib/components/pagination/info",
    "result": {"data":{"site":{"siteMetadata":{"title":"Eufemia - DNB Design System","description":"Eufemia Design System is the go to place for all who has to design, develop and make digital WEB applications for DNB."}},"mdx":{"slug":"uilib/components/pagination/info","frontmatter":{"title":"","description":null,"fullscreen":null,"showTabs":true,"hideTabs":null,"tabs":null},"tableOfContents":{"items":[{"url":"#description","title":"Description","items":[{"url":"#when-to-use-it","title":"When to use it:"},{"url":"#async-data-handling","title":"Async data handling"},{"url":"#screen-reader-support","title":"Screen reader support"},{"url":"#gotchas","title":"Gotchas"},{"url":"#legacy-browser-support-internet-explorer-11","title":"Legacy browser support (Internet Explorer 11)"},{"url":"#default-pagination-and-content-handling","title":"Default pagination and content handling","items":[{"url":"#pagination-method-1","title":"Pagination method #1"},{"url":"#pagination-method-2","title":"Pagination method #2"},{"url":"#pagination-method-3","title":"Pagination method #3"},{"url":"#pagination-method-4","title":"Pagination method #4"}]},{"url":"#infinity-scroller-and-content-handling","title":"Infinity scroller and content handling","items":[{"url":"#infinity-scroller-method-1","title":"Infinity scroller method #1"},{"url":"#infinity-scroller-method-2","title":"Infinity scroller method #2"},{"url":"#infinity-scroller-method-3","title":"Infinity scroller method #3"},{"url":"#infinity-scroller-method-4","title":"Infinity scroller method #4"}]}]}]},"body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"showTabs\": true\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h2\", null, \"Description\"), mdx(\"p\", null, \"The Pagination component supports both classical \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"page pagination\"), \" and \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"infinity scrolling\"), \".\"), mdx(\"h3\", null, \"When to use it:\"), mdx(\"p\", null, \"Use it to split up larger data sets into pages / sections so the users can interact sequential through the content.\"), mdx(\"h3\", null, \"Async data handling\"), mdx(\"p\", null, \"Infinity scrolling requires additional handling of already loaded content. To do so, it stores already shown content and interacts from there.\"), mdx(\"h3\", null, \"Screen reader support\"), mdx(\"p\", null, \"To make it easier for screen-readers to navigate, the \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"navigation bar\"), \" markup is placed above the content, even if it is visually the opposite.\"), mdx(\"h3\", null, \"Gotchas\"), mdx(\"p\", null, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Infinity scroller:\"), \" Once content inside a page changes, we have to tell the component explicit on what \\\"page\\\" number that happened, including the new content.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-jsx\"\n  }, \"setContent(pageNumber, ReactComponent)\\n\")), mdx(\"h3\", null, \"Legacy browser support (Internet Explorer 11)\"), mdx(\"p\", null, \"The \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"infinity scroller\"), \" is using the \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://developer.mozilla.org/en-US/docs/Web/API/Intersection_Observer_API\"\n  }, \"Intersection Observer API\"), \". This API is supported by all now-days browsers. But if your applications needs support for outdated browser, you can install e.g. \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://www.npmjs.com/package/intersection-observer\"\n  }, \"this IntersectionObserver polyfill\"), \" and import it:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-js\"\n  }, \"import 'intersection-observer'\\n\")), mdx(\"hr\", null), mdx(\"h3\", null, \"Default pagination and content handling\"), mdx(\"p\", null, \"You can either only use the pagination component with the buttons (bar) and have your content outside, but linked together with your own states.\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"or you put your content inside the pagination wrapper. This has the advantage that it gives screen-reader users an easier way to interact and understand the content.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"and it will \\\"keep\\\" the old page height until the next page is inserted, while showing an indicator.\")), mdx(\"h4\", null, \"Pagination method #1\"), mdx(\"p\", null, \"Returning a component directly inside a function child.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-jsx\"\n  }, \"import { Pagination } from '@dnb/eufemia/components'\\n\\nrender(\\n  <Pagination page_count={2}>\\n    {() => {\\n      return ReactComponent\\n    }}\\n  </Pagination>\\n)\\n\")), mdx(\"h4\", null, \"Pagination method #2\"), mdx(\"p\", null, \"Returning a function as a child and using \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"setContent\"), \".\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-jsx\"\n  }, \"import { Pagination } from '@dnb/eufemia/components'\\n\\nrender(\\n  <Pagination page_count={2}>\\n    {({ page, setContent }) => {\\n      setContent(page, ReactComponent)\\n    }}\\n  </Pagination>\\n)\\n\")), mdx(\"h4\", null, \"Pagination method #3\"), mdx(\"p\", null, \"Using the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"on_change\"), \" event together with \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"setContent\"), \".\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-jsx\"\n  }, \"import { Pagination } from '@dnb/eufemia/components'\\n\\nrender(\\n  <Pagination\\n    page_count={2}\\n    on_change={({ page, setContent }) => {\\n      setContent(page, ReactComponent)\\n    }}\\n  />\\n)\\n\")), mdx(\"h4\", null, \"Pagination method #4\"), mdx(\"p\", null, \"Create the instance before using it.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-jsx\"\n  }, \"import { createPagination } from '@dnb/eufemia/components/Pagination'\\n\\n// create our Component instance\\nconst { Pagination, setContent, resetContent } = createPagination()\\n\\n// Later we can do call this\\nsetContent(page, ReactComponent)\\n\\nrender(<Pagination page_count={2} />)\\n\")), mdx(\"hr\", null), mdx(\"h3\", null, \"Infinity scroller and content handling\"), mdx(\"p\", null, \"In order to update content into the internal pages stack, we have to get access to the component instance. There are several ways to do so.\"), mdx(\"p\", null, \"Also, there are two type of handling content on:\"), mdx(\"ol\", null, mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Either you fill the content as \\\"pages\\\" in a page per page basis (methods 1-3),\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"or you have your own stack, and you only want use the infinity part (method 4).\")), mdx(\"h4\", null, \"Infinity scroller method #1\"), mdx(\"p\", null, \"Create the instance before using it.\"), mdx(\"p\", null, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"NB:\"), \" Keep in mind, you may create the instance first during runtime, either in a class \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"constructor\"), \" or by using \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"useState\"), \":\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-jsx\"\n  }, \"import { createPagination } from '@dnb/eufemia/components/Pagination'\\n\\n// create our Component instance\\nconst { Pagination, setContent, endInfinity, resetContent } =\\n  React.useState(createPagination)\\n\\n// Later we can do call this (make sure the page is set by listening to the events)\\nsetContent(page, ReactComponent)\\n\\nrender(<Pagination mode=\\\"infinity\\\" />)\\n\")), mdx(\"h4\", null, \"Infinity scroller method #2\"), mdx(\"p\", null, \"Using the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"on_change\"), \" event together with \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"setContent\"), \".\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-jsx\"\n  }, \"import { Pagination } from '@dnb/eufemia/components'\\n\\nrender(\\n  <Pagination\\n    mode=\\\"infinity\\\"\\n    on_change={({ page, setContent }) => {\\n      setContent(page, ReactComponent)\\n    }}\\n  />\\n)\\n\")), mdx(\"h4\", null, \"Infinity scroller method #3\"), mdx(\"p\", null, \"Using a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"set_content_handler\"), \" handler.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-jsx\"\n  }, \"import InfinityScroller from '@dnb/eufemia/components/pagination/InfinityScroller'\\n\\nconst [localPage, setLocalPage] = React.useState(1)\\nconst setContent = React.createRef()\\n\\nReact.useEffect(() => {\\n  setContent.current(localPage, ReactComponent)\\n}, [localPage])\\n\\nrender(\\n  <InfinityScroller\\n    set_content_handler={(fn) => (setContent = fn)}\\n    on_change={({ page }) => {\\n      setLocalPage(page)\\n    }}\\n  />\\n)\\n\")), mdx(\"h4\", null, \"Infinity scroller method #4\"), mdx(\"p\", null, \"Using a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"InfinityMarker\"), \" only. See \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://github.com/dnbexperience/eufemia/tree/main/packages/dnb-eufemia-sandbox/stories/components/PaginationTableMarker.js\"\n  }, \"code example on GitHub\"), \".\"), mdx(\"p\", null, \"This method will basically add a load button on top, if \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"startup_page\"), \" or \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"current_page\"), \" is higher than \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"1\"), \" at the first render.\"), mdx(\"p\", null, \"Also, it adds an indicator at the bottom until next render, and as long as \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"page_count\"), \" has not reached the internal page count. But instead of setting \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"page_count\"), \" (total pages), you can pragmatically call \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"endInfinity()\"), \" instead.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-jsx\"\n  }, \"import { createPagination } from '@dnb/eufemia/components/Pagination'\\n\\n// create our Component instance\\nconst { InfinityMarker, endInfinity, resetInfinity } =\\n  React.useState(createPagination)\\n\\nrender(<InfinityMarker>ReactComponent</InfinityMarker>)\\n\")));\n}\n;\nMDXContent.isMDXComponent = true;","siblings":[{"slug":"uilib/components/pagination","frontmatter":{"menuTitle":null,"title":"Pagination","description":"The Pagination component supports both classical pagination and infinity scrolling.","fullscreen":null,"showTabs":true,"hideTabs":null,"tabs":null}},{"slug":"uilib/components","frontmatter":{"menuTitle":null,"title":"Components","description":null,"fullscreen":null,"showTabs":null,"hideTabs":null,"tabs":null}},{"slug":"uilib","frontmatter":{"menuTitle":null,"title":"UI Library","description":"Buttons, dropdowns, input fields, components etc.","fullscreen":null,"showTabs":null,"hideTabs":null,"tabs":null}}]}},"pageContext":{"id":"a0e7a021-f4b0-5018-8d0c-b52345d9f6ae","prev":{"id":"0e3d86ed-8833-5b17-80c1-a9748b193312","slug":"uilib/components/pagination/events"},"next":{"id":"52b244cc-7b80-5bef-b692-1d16bb3f5010","slug":"uilib/components/pagination/properties"}}},
    "staticQueryHashes": ["1824082843","2315317908","573224243"]}